---
title: "CV Task"
lang: "en-US"
draft: false
description: "Standardise structured outputs for computer vision tasks the open-source visual data ETL tool VDP https://github.com/instill-ai/vdp"
---

Computer Vision (CV) Tasks, a.k.a Vision Tasks, focus on analysing and understanding the content of visual data in the same way as human visual system does. The goal is to make a computer/device provide description for the data as complete and accurate as possible.
Some classic CV Tasks include image classification, object detection, image segmentation and keypoint detection. These primitive tasks are the foundation for building many real-world industrial vision applications.

Intrigued? Refer to [Prepare Models](/docs/prepare-models/overview) to learn about how to prepare your models for CV Tasks supported by VDP.

## Standardise CV Tasks

In a data pipeline, model is the core component designed to solve a specific CV Task. By standardising the data format of model outputs into CV Tasks,

- model in a pipeline is modularized: you can freely switch to use different models in a pipeline as long as the model is designed for the same CV Task;
- VDP produces a stream of data from models with standard format for use in a data integration or ETL pipeline.

At the moment, VDP defines the data interface for popular CV Tasks:

- _Image classification_ - classify images into predefined categories
- _Object detection_ - detect and localise multiple objects in images
- _Keypoint detection_ - detect and localise multiple keypoints of objects in images
- _OCR (Optical Character Recognition)_ - detect and recognise text in images
- _Instance segmentation_ - detect, localise and delineate multiple objects in images
- The list is growing ... ðŸŒ±

Each CV Task is described in depth in the respective section below.

If you'd like to **ask for a new model definition**, you can create a topic in [Discussions](https://github.com/instill-ai/vdp/discussions), or request it in the **#vdp** channel on [Discord](https://discord.gg/sevxWsqpGh).

## How to standardise

### Standardise via Protocol Buffers

Currently, the model output is converted to standard format based on the CV Task outputs maintained in [Protobuf](https://github.com/instill-ai/protobufs/tree/main/vdp/model/v1alpha).

### Standardise via VDP Protocol

The [VDP Protocol](https://github.com/instill-ai/vdp/blob/main/protocol/vdp_protocol.yaml) describes the data schema of CV Task output in order to standardise an ETL pipeline for visual data.
The data produced by the model component and passed to destination component of a pipeline is done via serialized JSON messages for inter-process communication.

```yaml
"$schema": http://json-schema.org/draft-07/schema#
"$id": https://github.com/instill-ai/vdp/blob/main/protocol/vdp_protocol.yaml
title: VDP Protocol
type: object
description: VDP Protocol structs
additionalProperties: true
anyOf:
  - required:
      - classification
  - required:
      - detection
  - required:
      - keypoint
  - required:
      - ocr
  - required:
      - instance_segmentation
  - required:
      - unspecified
properties:
  classification:
    description: "Classify into pre-defined categories"
    "$ref": "#/definitions/Classification"
  detection:
    description: "Detect and localise multiple objects"
    "$ref": "#/definitions/Detection"
  keypoint:
    description: "Detect and localise keypoints of multiple objects"
    "$ref": "#/definitions/Keypoint"
  ocr:
    description: "Detect, localise and recognise texts"
    "$ref": "#/definitions/Ocr"
  instance_segmentation:
    description: "Detect, localise and delineate multiple objects"
    "$ref": "#/definitions/InstanceSegmentation"
  unspecified:
    description: "Unspecified task with output in the free form"
    "$ref": "#/definitions/Unspecified"
```

To be more specific, the above protocol defines the CV Task output for one input image in a batch produced by the corresponding model instance.

The protocol is still under development. Stay tuned on how the protocol will evolve.

## Image classification

Image classification is a CV Task to assign a single pre-defined category label to an entire input image.
Generally, an image classification model takes an image as the input, and outputs a prediction about what category this image belongs to and a confidence score (usually between 0 and 1) representing the likelihood that the prediction is correct.

<ZoomableImg
  src="/docs-assets/core-concepts/cv-task-classification.svg"
  alt="Image classification task"
/>

```json
{
  "classification": {
    "category": "golden retriever",
    "score": 0.98
  }
}
```

## Object detection

Object detection is a CV Task to localise multiple objects of pre-defined categories in an input image.
Generally, an object detection model receives an image as the input, and outputs bounding boxes with category labels and confidence scores on detected objects.

<ZoomableImg
  src="/docs-assets/core-concepts/cv-task-detection.svg"
  alt="Object detection task"
/>

```json
{
  "detection": {
    "objects": [
      {
        "category": "dog",
        "score": 0.97,
        "bounding_box": {
          "top": 102,
          "left": 324,
          "width": 208,
          "height": 405
        }
      },
      ...
    ]
  }
}
```

## Keypoint detection

Keypoint detection task is a CV Task to localise multiple objects by identifying their pre-defined keypoints, for example, identifying the keypoints of human body: nose, eyes, ears, shoulders, elbows, wrists, hips, knees and ankles.
Normally, a keypoint detection task takes an image as the input, and outputs the coordinates and visibility of keypoints with bounding boxes and confidence scores on detected objects.

<ZoomableImg
  src="/docs-assets/core-concepts/cv-task-keypoint.svg"
  alt="Keypoint detection task"
/>

```json
{
  "keypoint": {
    "objects": [
      {
        "keypoints": [
          {
            "v": 0.53722847,
            "x": 542.82764,
            "y": 86.63817
          },
          {
            "v": 0.634061,
            "x": 553.0073,
            "y": 79.440636
          },
          ...
        ],
        "score": 0.94,
        "bounding_box": {
          "top": 86,
          "left": 185,
          "width": 571,
          "height": 203
        }
      },
      ...
    ]
  }
}
```

## Optical Character Recognition (OCR)

OCR is a CV Task to localise and recognise text in an input image.
The task can be done in two steps by multiple models:
a text detection model to detect bounding boxes containing text and
a text recognition model to process typed or handwritten text within each bounding box into machine readable text.
Alternatively, there are deep learning models that can accomplish the task in one single step.

<ZoomableImg src="/docs-assets/core-concepts/cv-task-ocr.svg" alt="OCR task" />

```json
{
  "ocr": {
    "objects": [
      {
        "text": "ENDS",
        "score": 0.99,
        "bounding_box": {
          "top": 298,
          "left": 279,
          "width": 134,
          "height": 59
        }
      },
      {
        "text": "PAVEMENT",
        "score": 0.99,
        "bounding_box": {
          "top": 228,
          "left": 216,
          "width": 255,
          "height": 65
        }
      }
    ]
  }
}
```

## Instance Segmentation

Instance segmentation is a CV Task to detect and delineate multiple objects of pre-defined categories in an input image.
Normally, the task takes an image as the input, and outputs uncompressed run-length encoding (RLE) representations (a variable-length comma-delimited string),
with bounding boxes, category labels and confidence scores on detected objects.

![Instance Segmentation task](/docs-assets/core-concepts/cv-task-instance-segmentation.svg)

Run-length encoding (RLE) is an efficient form to store binary masks. It is commonly used to encode the location of foreground objects in segmentation.
We adopt [the uncompressed RLE definition used in COCO dataset](https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocotools/mask.py).
It divides a binary mask (must in colume-major order) into a series of piecewise constant regions and for each piece simply stores the length of that piece.

<p align="center">
  <img
    src="/docs-assets/core-concepts/cv-task-mask-rle.svg"
    alt="Examples of encoding masks into RLEs and decoding masks encoded via RLEs"
    width="320"
  />
  Examples of encoding masks into RLEs and decoding masks encoded via RLEs. Note
  that the odd counts in the RLEs are always the numbers of zeros.
</p>

:::info{type=info}
Check out functions to [encode masks into RLEs](https://github.com/instill-ai/vdp/blob/30357c0581ecdbb5e74584906cdc547587ca3af7/examples/streamlit/stomata/utils.py#L81-L101) and [decode masks encoded via RLEs](https://github.com/instill-ai/vdp/blob/30357c0581ecdbb5e74584906cdc547587ca3af7/examples/streamlit/stomata/utils.py#L103-L121).
:::

```json
{
  "instance_segmentation": {
    "objects": [
      {
        "rle": "2918,12,382,33,...",
        "score": 0.99,
        "bounding_box": {
          "top": 95,
          "left": 320,
          "width": 215,
          "height": 406
        },
        "category": "dog"
      },
      {
        "rle": "34,18,230,18,...",
        "score": 0.97,
        "bounding_box": {
          "top": 194,
          "left": 130,
          "width": 197,
          "height": 248
        },
        "category": "dog"
      }
    ]
  }
}
```

## What if my task is not standardised by by VDP yet?

VDP is very flexible and allows you to import models even if your task is not standardised yet or the output of the model can't be converted to the format of supported CV Tasks.
The model will be classified as an `Unspecified` CV Task. Send an image to the model as the input,
VDP will

- check the `config.pbtxt` [model configuration](https://github.com/triton-inference-server/server/blob/main/docs/model_configuration.md) file to extract the output names, datatypes and shapes of the model outputs,
- and wrap these information along with the raw model output in a _standard_ format.

<ZoomableImg
  src="/docs-assets/core-concepts/cv-task-unspecified.svg"
  alt="Unspecified task"
/>

```json
{
  "unspecified": {
    "raw_outputs": [
      {
        "data": [0.85, 0.1, 0.05],
        "data_type": "FP32",
        "name": "output_scores",
        "shape": [3]
      },
      {
        "data": ["dog", "cat", "rabbit"],
        "data_type": "BYTES",
        "name": "output_labels",
        "shape": [3]
      }
    ]
  }
}
```
